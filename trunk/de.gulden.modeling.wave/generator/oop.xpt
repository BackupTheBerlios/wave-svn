«REM»
    WAVE - Web Application Visual Environment
    A Graphical Modeling Framework (GMF) Plugin for Eclipse
    Copyright Jens Gulden, 2009, mail@jensgulden.de
    Licensed under the GNU General Public License (GPL)
«ENDREM»

«IMPORT wave»

«EXTENSION org::openarchitectureware::util::stdlib::globalvar»
«EXTENSION common»
«EXTENSION sql::sql»

«EXTENSION zend::commonZend» «REM»TODO remove and make language freely configurable (maybe via AROUND-templates on Xpand-level, not via Xtend)«ENDREM»


«REM» ---   language-specific templates   --- «ENDREM»

«REM»TODO make language-specific templates 'abstract' (by delivering empty content), and configure language specific output via AROUND templates«ENDREM»

«DEFINE className FOR OOPClassifier»«this.codeName()»«ENDDEFINE»

«REM» --- END language-specific templates --- «ENDREM»

«DEFINE attributes FOR Classifier»«FOREACH this.attributes AS attr»«IF attr.isFinal && attr.isStatic»
const «attr.name» = «attr.defaultValue»;«ELSE»
/**
 * Attribute '«attr.name»'
 */
//«this.metaclass()»
«attr.visibility()»«IF attr.isStatic» static«ENDIF» «IF attr.type.is()»/*«attr.type.translateType()»*/ «ENDIF»«EXPAND attribute FOR attr»«IF (this.isClass()) && (attr.type == "array")» = array()«ENDIF»;«IF ! this.definesOperation("get"+attr.name.toFirstUpper())»
/**
 * @generated
 */
public function /*«attr.type»*/ get«attr.name.toFirstUpper()»() {
	return $this->«attr.name»;
} 
«ENDIF»«IF ! this.definesOperation("set"+attr.name.toFirstUpper())»
/**
 * @generated
 */
public function /*void*/ set«attr.name.toFirstUpper()»(/*«attr.type»*/$«attr.name») {
	$this->«attr.name»=$«attr.name»;
} 
«ENDIF»«ENDIF»«ENDFOREACH»«ENDDEFINE»

«DEFINE operations FOR Classifier»«FOREACH this.operations AS op»
«op.visibility()» «EXPAND modifiers FOR op»function /*«op.returnType.translateType()»*/ «op.name»(«EXPAND parameters FOR op»)«IF op.throws.is()» throws «op.throws»«ENDIF»«IF op.isAbstract || this.isInterface()»;«ELSE»
/*begin «op.signatureID()»*/
{
	«op.prepareCode()»
}
/*end «op.signatureID()»*/
«ENDIF»
«ENDFOREACH»«ENDDEFINE»

«DEFINE associations FOR Class-»
	«FOREACH this.associations() AS assoc-»
		«IF assoc.isNavigable(this)-»
/**
 * Association '«assoc.name»'
 * «this.ingoingMultiplicity(assoc)» «IF (assoc.direction.toString() != "<-->")»-->«ELSE»--«ENDIF» «this.outgoingMultiplicity(assoc)»
 * @generated
 */
protected /*«IF this.isOutgoingMulti(assoc)»array«ELSE»integer«ENDIF»*/ $«this.outgoingName(assoc)»«IF this.isOutgoingMulti(assoc)» = array()«REM»«IF this.isPersistent»null«ELSE»array()«ENDIF»«ENDREM»«ENDIF»;
			«IF ! this.definesOperation("get"+this.outgoingName(assoc).toFirstUpper())-»
				«IF ! this.isOutgoingMulti(assoc)»
/**
 * @generated
 */
public function /*«this.outgoingType(assoc).name»*/ get«this.outgoingName(assoc).toFirstUpper()»() {
	return $this->«this.outgoingName(assoc)»; 
} 
				«ELSE»
/**
 * @generated
 */
public function /*Array*/ get«this.outgoingName(assoc).toFirstUpper()»() {
	return $this->«this.outgoingName(assoc)»; 
} 

/**
 * @generated
 */
public function set«this.outgoingName(assoc).toFirstUpper()»(Array $values) {
	$this->«this.outgoingName(assoc)» = $values; 
} 
				«ENDIF» 
			«ENDIF-»
				«IF ! this.isOutgoingMulti(assoc)-»
					«IF ! this.definesOperation("set"+this.outgoingName(assoc).toFirstUpper())-»
/**
 * @generated
 */
public function /*void*/ set«this.outgoingName(assoc).toFirstUpper()»(«EXPAND className FOR this.outgoingType(assoc)» $«this.outgoingName(assoc)»=null) {
	$this->«this.outgoingName(assoc)»=$«this.outgoingName(assoc)»;
						«IF assoc.isBidirectional()-»«REM» bi-drectional 1:1 «ENDREM»
	if (($«this.outgoingName(assoc)» != null) && ($«this.outgoingName(assoc)» != $this->«this.outgoingName(assoc)»)) {
							«IF ! assoc.isIngoingMulti(this)-»
		$«this.outgoingName(assoc)»->set«this.ingoingName(assoc).toFirstUpper()»($this); // set back-reference
							«ELSE-» 
		$«this.outgoingName(assoc)»->add«this.ingoingName(assoc).toFirstUpper().removePluralS()»($this); // add back-reference
							«ENDIF-» 
	}
						«ENDIF-» 
} 
					«ENDIF-» 
				«ELSE»
					«IF ! this.definesOperation("add"+this.outgoingName(assoc).toFirstUpper().removePluralS())-»
/**
 * @generated
 */
public function /*void*/ add«this.outgoingName(assoc).toFirstUpper().removePluralS()»(«EXPAND className FOR this.outgoingType(assoc)» $«this.outgoingName(assoc).removePluralS()») {
						«IF this.isPersistent-» 
	$this->get«this.outgoingName(assoc).toFirstUpper()»(); // make sure is initialized
						«ENDIF-» 
	if ( ! in_array( $«this.outgoingName(assoc).removePluralS()», $this->«this.outgoingName(assoc)» ) ) {
		$this->«this.outgoingName(assoc)»[] = $«this.outgoingName(assoc).removePluralS()»;
							«IF assoc.isBidirectional()-»«REM» bi-drectional 1:m «ENDREM»
								«IF ! assoc.isIngoingMulti(this)-»
		$«this.outgoingName(assoc).removePluralS()»->set«this.ingoingName(assoc).toFirstUpper()»($this); // set back-reference
								«ELSE-» 
		$«this.outgoingName(assoc).removePluralS()»->add«this.ingoingName(assoc).toFirstUpper().removePluralS()»($this); // add back-reference (!!)
								«ENDIF-» 
							«ENDIF-» 
	}
} 
					«ENDIF-» 
				«ENDIF-»
				
				
		«IF this.isOutgoingMulti(assoc)»
				 
			«IF ! this.definesOperation("remove"+this.outgoingName(assoc).toFirstUpper().removePluralS())-»
/**
 * @generated
 */
public function /*void*/ remove«this.outgoingName(assoc).toFirstUpper().removePluralS()»(«EXPAND className FOR this.outgoingType(assoc)» $«this.outgoingName(assoc).removePluralS()») {
						«IF (!this.isInterface()) && this.isPersistent-» 
	$this->get«this.outgoingName(assoc).toFirstUpper()»(); // make sure is initialized
						«ENDIF-» 
	if ( in_array( $«this.outgoingName(assoc).removePluralS()», $this->«this.outgoingName(assoc)» ) )
	{
		$found = -1;
		for ($i = 0; $i < count($this->«this.outgoingName(assoc)»); $i++)
		{
			if ($«this.outgoingName(assoc).removePluralS()» == $this->«this.outgoingName(assoc)»[$i])
			{
				$found = $i;
			}
		}
		unset( $this->«this.outgoingName(assoc)»[$found] );
		
		«REM» TODO
		
							«IF assoc.isBidirectional()-»«xREM» bi-drectional 1:m «xENDREM»
								«IF ! this.isIngoingMulti(assoc)-»
		$«this.outgoingName(assoc)»->set«this.ingoingName(assoc).toFirstUpper()»(null); // remove back-reference
								«ELSE-»
		$«this.outgoingName(assoc).removePluralS()»->remove«this.ingoingName(assoc).toFirstUpper()»($this); // remove back-reference
								«ENDIF-»
							«ENDIF-»
							
		«ENDREM»
	} 
} 
			«ENDIF-» 
			«IF ! this.definesOperation("removeAll"+this.outgoingName(assoc).toFirstUpper()+"s")-»
/**
 * @generated
 */
public function /*void*/ removeAll«this.outgoingName(assoc).toFirstUpper()»() {
	foreach ($this->get«this.outgoingName(assoc).toFirstUpper()»() as $key=>$val) {
		$this->remove«this.outgoingName(assoc).toFirstUpper().removePluralS()»($key);
	}
} 
			«ENDIF-»
		«ENDIF-»
		«ENDIF-»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE parameters FOR Operation»«FOREACH this.parameters AS param SEPARATOR ", "»«IF param.type.is()»/*«param.type.translateType()»*/«ENDIF»«EXPAND attribute FOR param»«ENDFOREACH»«ENDDEFINE»

«DEFINE parametersFromHttp FOR Operation-»
	// --- HTTP parameters ---
	«FOREACH this.parameters AS param-»
		«IF param.type.isPrimitiveType()-»
			«IF param.type.isArrayType()-»
	/*«param.type»*/ $«param.name» = $_REQUEST["«param.name»"];
			«ELSE-»
	«IF param.type.is()»/*«param.type.translateType()»*/ «ENDIF»$«param.name» = «IF param.type.typeCastFunction().is()»«param.type.typeCastFunction()»($_REQUEST["«param.name»"])«ELSE»$_REQUEST["«param.name»"]«ENDIF»;
			«ENDIF-»
		«ELSE-»
			«IF param.type.isArrayType()-»
	/*«param.type»*/ $«param.name» = «param.type»::_getAllFromHttp("«param.name»_");
			«ELSE-»
	/*«param.type»*/ $«param.name» = «param.type»::_getFromHttp("«param.name»_");
			«ENDIF-»
		«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE attribute FOR Attribute»$«this.name»«IF this.defaultValue.is()» = «this.defaultValue»«ENDIF»«ENDDEFINE»

«DEFINE modifiers FOR OOPClassifier»«IF this.isAbstract»abstract «ENDIF»«ENDDEFINE»

«DEFINE modifiers FOR Attribute»«IF this.isFinal»final «ENDIF»«IF this.isStatic»static «ENDIF»«ENDDEFINE»

«DEFINE modifiers FOR Operation»«IF this.isAbstract»abstract «ENDIF»«IF this.isFinal»final «ENDIF»«IF this.isStatic»static «ENDIF»«ENDDEFINE»

«DEFINE imports FOR Classifier-»
	«FOREACH this.depends() AS m-»
		«EXPAND resolveImport FOR m-»
	«ENDFOREACH-»
	«FOREACH this.extends() AS m-»
		«EXPAND resolveImport FOR m-»
	«ENDFOREACH-»
	«FOREACH this.implements() AS m-»
		«EXPAND resolveImport FOR m-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE resolveImport FOR ModelMember-»«REM»nop«ENDREM»«ENDDEFINE»

«DEFINE resolveImport FOR Class-»
include_once($_rel."/«this.sourceFileName()»");
«ENDDEFINE»

«DEFINE resolveImport FOR Interface-»
include_once($_rel."/«this.sourceFileName()»");
«ENDDEFINE»

«DEFINE resolveImport FOR Enumeration-»
include_once($_rel."/«this.sourceFileName()»");
«ENDDEFINE»

«DEFINE resolveImport FOR Package-»
	«FOREACH this.members AS m-»
		«EXPAND resolveImport FOR m-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE resolveImport FOR Include-»
«IF this.taggedValue("layoutTemplate").is()-»
«ELSE-»
include_once($_rel."/«this.sourceFileName()»");
«ENDIF-»
«ENDDEFINE»

